#version 450
layout (local_size_x = 1, local_size_y = 1) in;
layout(binding = 0, rgba32f) uniform  image2D outputValues;

layout(binding = 1, rgba32f) uniform readonly  image2D values;
//readonly
layout(binding = 2, rgba32f) uniform readonly image2D filterValues;
layout (constant_id = 0) const uint BUFFER_ELEMENTS = 32;
//32-bit IEEE 754 binary32 format representation of real number 1:
// https://en.wikipedia.org/wiki/Single-precision_floating-point_format
// https://www.h-schmidt.net/FloatConverter/IEEE754.html
void main() 
{
	//uint index = gl_GlobalInvocationID.x;
	uint row = (gl_GlobalInvocationID.x);
	uint col = (gl_GlobalInvocationID.y);	
	vec4 x= imageLoad(values,ivec2(row, col)).rgba;
	vec4 w = imageLoad(filterValues,ivec2(row, col)).rgba; 
	// vec4 res = x; //0,1,2,3,4,5,6,7,8,9
	// vec4 res = w; // a,b,c,d,e,f,10,11,12,13,14
	//vec4 res = imageLoad(values,ivec2(row, col)) + imageLoad(filterValues,ivec2(row, col));
	// vec4 res = vec4(x.r+w.r,x.g+w.g,x.b+w.b,x.a+w.a); //0,0,0,0,0,0,0,0,0,
	// vec4 res = w - x; // 0,0,0,0,0,0,0,0,0,
	
	vec4 res = x + w;
	//vec4 res = vec4(x.r,x.g,x.b,x.a);
	// vec4 res = vec4(x.r+1.0,x.g+1.0,x.b+1.0,x.a+1.0);
	/*
	if(gl_GlobalInvocationID.x % 4 == 0)
	res = vec4(1,2,3,4);
	else if(gl_GlobalInvocationID.x % 4 == 1)
	res = vec4(5,6,7,8);
	else if(gl_GlobalInvocationID.x % 4 == 2)
	res = vec4(9,10,11,12);
	else if(gl_GlobalInvocationID.x % 4 == 3)
	res = vec4(13,14,15,16);
	*/


	imageStore(outputValues, ivec2(gl_GlobalInvocationID.xy), res);


	// vec4 res = vec4(x.r+1.0,x.g+1.0,x.b+1.0,x.a+1.0);// x + vec4(1,1,1,1);//vec4(x.r+w.r,x.g+w.g,x.b+w.b,x.a+w.a);

/*
	for (int row = 0; row < 4; ++row) {
		for (int col = 0; col < 8; ++col) {
			vec4 rgba = imageLoad(values,ivec2(row, col)).rgba;
			acc += int(rgba.r+rgba.g+rgba.b+rgba.a);
			
		}
	}

	for (int row = 0; row < 8; ++row) {
		for (int col = 0; col < 4; ++col) {
			vec4 rgba = imageLoad(values,ivec2(row, col)).rgba;
			acc += int(rgba.r+rgba.g+rgba.b+rgba.a);
			
		}
	}

	for (int row = 0; row < 4; ++row) {
		for (int col = 0; col < 8; ++col) {
			vec4 rgba = imageLoad(filterValues,ivec2(row, col)).rgba;
			acc += int(rgba.r+rgba.g+rgba.b+rgba.a);
			
		}
	}

	for (int row = 0; row < 8; ++row) {
		for (int col = 0; col < 4; ++col) {
			vec4 rgba = imageLoad(filterValues,ivec2(row, col)).rgba;
			acc += int(rgba.r+rgba.g+rgba.b+rgba.a);
			
		}
	}
*/
	// outputValues[index] = acc+100;
    //vec4 res = vec4(vec3(1, 2, 3), 4);//float(acc+index));
    //res = vec4(vec3(1, 1, 1), 1);
	// imageStore(outputValues, ivec2(gl_GlobalInvocationID.xy), res);

	//if ()
	//if (index >= BUFFER_ELEMENTS) 
	//	return;	
    //vec4 rgba = imageLoad(values,ivec2(gl_GlobalInvocationID.xy)).rgba;
    //vec4 drgba = imageLoad(filterValues,ivec2(gl_GlobalInvocationID.xy)).rgba;
    //imageStore(values,  100;
    //imageStore(values, ivec2(0,0), vec4(222,111,112,113));
    //vec4 rgba = imageLoad(values,ivec2(0,0)).rgba;
    //outputValues[index] = int(rgba.r+rgba.g+rgba.b+rgba.a);;
    //outputValues[index] = int(rgba.r+rgba.g+rgba.b+rgba.a)+int(drgba.r+drgba.g+drgba.b+drgba.a);
	//outputValues[index] = int(imageLoad(values,ivec2(gl_GlobalInvocationID.xy)).r);// + int(imageLoad(filterValues,ivec2(gl_GlobalInvocationID.xy)));
}

